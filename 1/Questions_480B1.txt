COSC 480B Assignment #1: Secure Messaging


NAMES: Chase (Xi) Jiang, Nhiem Ngo

______________________________________________________________________________________

Question #1
Describe the protocol you agreed upon with your classmates in English (no code) in
enough detail that someone else provided with InsecureMessaging.py could implement it. 

1. We used the Diffie-Hellman key exchange protocol.
2. If the host is a client, we first generate a public key using the built-in method gen_public_key() from pyDH.DiffieHellman().
3. We then sends that key to the server communicating with us, and receive another public key from them, generated by the same source.
4. We then use those 2 keys to derive a shared secret key using the gen_shared_key() method from pyDH.DiffieHellman()
5. And this shared key will be used for the client to encrypt messages send to the server.
6. We then repeat the above process again to generate another shared secret key, and this shared key will be used for the client to decrypt messages from the server.
7. If the host is a server, we repeat the same procedure as for the client but the shared keys will be used differently as described below.
8. The first shared key will be used for the server to decrypt messages received from the client.
9. The second shared key will be used for the server to encrypt messages send to the client.
10. To encrypt messages, we specifically used the AES cipher from the library provided by pycryptodome along with two arguments:a) specified shared key b) MODE_EAX.
11. Note: for all the shared keys used as an argument for the AES cipher, the key should be truncated using [:32] to satisfy AES MODE_EAX requirement.
12. By utilizing the built in functions for the cipher, we can encrypt our message into a ciphertext as well as generating a nonce and a tag for the message.
13. Upon the encryption of the message, we sent to the communicating host a message composed of the nonce, ciphertext, and the tag in this specific order.
14. The nonce, ciphertext, and the tag in the message are splitted by b'splt'.
15. The decryption process takes a received message and split it into the nonce, ciphertext, and the tag using the delimiter b'splt'.
16. An AES cipher object is created using the arguments a) appropriated shared key, b)AES.MODE_EEAX, and c) nonce.
16. The ciphertext is then deciphered to plaintext using the built in function for the cipher object.
17. At the same time, by running the cipher's verify function using the tag as the argument, we can check to make sure messages weren't tampered with.

______________________________________________________________________________________

Question #2
Describe two pros, two cons, OR one pro and one con of the protocol you agreed upon 
with your classmates.

Pro: 
a) This protocol is relatively secure as it provides certain level of confidentiality and integrity through the use of both symmetric and asymmetric cryptographies.
b) The implementation of this protocol is relatively simple as we utilize the built in verification, encryption, and decryption functions from the cipher.


Con: 
a) This protocol is vulnerable to MITM attack. The public keys were sent over an insecure channel. Say, if someone from ITS was able to grab the public keys we sent
along the network, they could be posing as the person we think we're messaging with, and decipher our messages.
b) The protocol may be subjective to bruteforce attacks as the keys used may not be sufficiently long enough.

______________________________________________________________________________________

Question #3
Thinking like a defender, what/who do you have to trust in order to be confident
that messages sent using your SecureMessaging.py cannot be obtained by an adversary and why? 
Describe at least THREE entities you must trust.  

We must trust that the network encryption protocols is secure and traffic we sent cannot be easily accessed.
As we're operating on Colgate network, we must trust that eduroam itself is secure and ColgateGuest is not being used, for example.
We must also trust that ITS is not tampering with or looking into our traffic.

We must trust that the person we're communicating with is actually our friend, and not an adversary posing as one.
Since this program provides little authentication of identity, we can't know for certain if the Server IP and port number we connect to actually points to a server our friend set up.

We must trust that the system we're running SecureMessaging.py on is not vulnerable to attacks, and that they don't record our yet-to-be-encrypted or decrypted messages.

______________________________________________________________________________________

Question #4
Thinking like an attacker, how might an adversary still compromise the confidentiality or 
integrity of a message sent to a classmate using your SecureMessage.py? 
Describe at least TWO potential attacks. 

SecureMessage.py does not seem to provide any authentication method. That is, we won't know if the person
we think we're communicating with is actually our friend. Someone posing as our friend can set up a server
and read our messages.
DH key exchange is vulnerable to MITM attacks. Say, if someone from ITS gets hold of the keys we exchange over
the unsecure channel, they might intercept the messages sent between us and our friends.
In addition, this specific implementation of the protocol uses secret key truncated by [:32] which may cause it to be vulnerable to brute force attacks.

______________________________________________________________________________________

Question #5 (ungraded)
How did you divide the work between partners? (Put N/A if worked alone)

We worked together to derive the protocol and creating the code. Chase was the main driver on implementing the code while Nhiem provides input and suggestions for optimization.

______________________________________________________________________________________

Question #6 (optional, ungraded)
Did you use code snippets from anywhere online that you need to cite?
https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html
https://github.com/amiralis/pyDH

[Your answer here]

______________________________________________________________________________________

Question #7 (optional, ungraded) 
Do you have any suggestions for improving this assignment in the future?
Students can be a little bit more proactive in terms of communication.

[Your answer here]